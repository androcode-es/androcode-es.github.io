<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Inicio &middot; Androcode
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface|Roboto+Condensed:bold">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-androcode">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          <img class="sidebar-logo" src="/public/logo_white_100w.png" />
          Androcode
        </a>
      </h1>
      <p class="lead">Androcode es programación, Androcode es tecnología, Androcode necesita una descripción nueva.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Inicio</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">¿Quiénes somos?</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/androteca/">La Androteca</a>
          
        
      
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    </nav>

    <nav class="sidebar-social">
      <ul class="navigation">

        <li class="social-item twitter">
          <a href="http://twitter.com/@androcode" title="@androcode on Twitter" target="_blank">
            <i class="icon fa fa-twitter"></i>
            <span class="label">Twitter</span>
          </a>
        </li>

        <li class="social-item gplus">
          <a href="https://plus.google.com/+AndrocodeEs/posts" title="+AndrocodeEs" target="_blank">
            <i class="icon fa fa-google-plus-square"></i>
            <span class="label">Google+</span>
          </a>
        </li>

        <li class="social-item github">
          <a href="http://github.com/androcode-es" title="@androcode-es on GitHub" target="_blank">
            <i class="icon fa fa-github"></i>
            <span class="label">GitHub</span>
          </a>
        </li>
      </ul>
    </nav>

    <p class="sidebar-foot-note">&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/17/trabajando-con-parcelables/">
        Trabajando con Parcelables
      </a>
    </h1>

    <span class="post-date">17 Dec 2012</span>

    <p>Hola a todos! hoy me estreno en androcode.es con un artículo sobre tipos parcelables, si no sabes lo que son, hoy aprenderás para qué sirven y cómo implementarlos.
<a href="http://androcode.es/wp-content/uploads/2015/02/decibels_zesjsx.png"><img src="http://androcode.es/wp-content/uploads/2015/02/decibels_zesjsx-300x201.png" alt="" title="teach"></a></p>

<p>Normalmente cuando queremos pasar un objeto entre actividades tenemos varias opciones, unas más elegantes y otras menos.</p>

<p>Tal vez lo primero que se nos ocurra sea guardar el objeto en un campo static de una de nuestras clases, y recuperarlo en la nueva actividad, pero este tipo de prácticas no están muy bien vistas ya que puedes incurrir en problemas de concurrencia, leaks de memoria, etc.</p>

<p>Puede que lo siguiente que se te ocurra sea implementar en el objeto la interfaz serializable. Esta solución no es mala para objetos pequeños pero en la práctica es muy lenta y si vamos a serializar un objeto complejo y grande, no es la mejor solución. Por eso el equipo de android decidió inventarse los tipos parcelables, que en la práctica es como escribir los tipos en un <a href="http://developer.android.com/reference/android/os/Bundle.html">Bundle</a> y recuperarlos después. De echo el objeto Bundle implementa la interfaz Parcelable y cuando haces intent.putExtra(&quot;key&quot;,&quot;hello world&quot;), estás escribiendo un Bundle asociado al intent, y cuando haces getIntent().getExtras() para leer, es un Bundle de donde lees.</p>

<p>Pero vamos a ver esto con más detalle y vamos a ver como podemos implementar la interfaz <a href="http://developer.android.com/reference/android/os/Parcelable.html">Parcelable</a> en nuestros objetos para pasarlos entre actividades o servicios de una manera rápida.  </p>

<p>Puedes descargarte el <a href="https://github.com/ferdy182/Android-parcelable-example" title="ferdy182 en GitHub Android parcelable example">código de ejemplo de github</a> Lo primero es crearnos una clase que implemente la interfaz <a href="http://developer.android.com/reference/android/os/Parcelable.html">Parcelable</a>
```
package com.example.parcelable;</p>

<p>import android.os.Parcel;
import android.os.Parcelable;</p>

<p>public class Estudiante implements Parcelable {</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
public int describeContents() {
    return 0;
}

@Override
public void writeToParcel(Parcel dest, int flags) {

}
</code></pre></div>
<p>}
```</p>

<p>Esto nos creará un par de métodos en la clase, describeContents, que en los ejemplos siempre ponen return 0; así que de momento no nos preocupamos, y el método writeToParcel que recibe un objeto Parcel de destino y un flag que puede ser 0 o <a href="http://developer.android.com/reference/android/os/Parcelable.html#PARCELABLE_WRITE_RETURN_VALUE"><em>PARCELABLE<em>WRITE</em>RETURN_VALUE</em></a>.</p>

<p>Yo recomiendo añadir otro constructor al objeto que reciba un Parcel para recrearlo a partir de ahí y un método readFromParcel(Parcel in) para rellenar los campos del objeto y tenerlo más ordenado.</p>

<p>Además vamos a añadirle unos campos a la clase, porque una clase sin campos no vale para mucho ¿no?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">package com.example.parcelable;

import java.util.List;

import android.os.Parcel;
import android.os.Parcelable;

public class Estudiante implements Parcelable {
    int fechaNacimiento;
    String nombreCompleto;
    boolean esHijoUnico;
    float[] notas;
    List&amp;lt;Estudiante&amp;gt; amigos;

    public Estudiante() {
        notas = new float[3];
        amigos = new ArrayList&amp;lt;Estudiante&amp;gt;();
    }

    public Estudiante(Parcel in) {
        notas = new float[3];
        amigos = new ArrayList&amp;lt;Estudiante&amp;gt;();
        readFromParcel(in);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {

    }

    private void readFromParcel(Parcel in) {

    }

}
</code></pre></div>
<p>Cómo veis, he añadido unos campos de distintos tipos, incluidos un array de floats y una lista tipada (para que veáis que se pueden meter distintos tipos en un Parcel).</p>

<p>Ahora vamos a ver la chicha, cómo guardar el objeto en un Parcel y como recuperarlo después.</p>

<p>Básicamente el objeto Parcel nos expone unos métodos para escribir nuestros campos según su tipo para no equivocarnos, por lo que rellenamos nuestro método writeToParcel de la forma siguiente:
<code>
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(fechaNacimiento);
    dest.writeString(nombreCompleto);
    dest.writeBooleanArray(new boolean[]{esHijoUnico});
    dest.writeFloatArray(notas);
    dest.writeTypedList(amigos);
}
</code>
Mientras escribía esto he descubierto que <a href="http://code.google.com/p/android/issues/detail?id=5973">no hay un método Parcel.writeBoolean(boolean val)</a> (gracias Google!) por lo que podéis o bien escribirlo en un array de booleans con un único valor, o escribir un byte y luego parsearlo como boolean.</p>

<p>Ahora vamos a ver como recuperaríamos nuestro objeto de un Parcel, así que rellenamos el método readFromParcel de esta manera:
```
private void readFromParcel(Parcel in) {
    fechaNacimiento = in.readInt();
    nombreCompleto = in.readString();</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">boolean[] temp = new boolean[1];
in.readBooleanArray(temp);
esHijoUnico = temp[0];

in.readFloatArray(notas);
in.readTypedList(amigos, CREATOR);
</code></pre></div>
<p>}
<code>
¡Ostras! Para leer una lista tipada necesito un objeto Parcelable.Creator, ¿qué es eso? Digamos que es un objeto que genera objetos del tipo que le digas a partir de un Parcel (vamos, lo que veníamos haciendo) pero es necesario para recrear los objetos en otros Parcelables. Es muy sencillo, sólo hay que añadir esto:
</code>
public static final Parcelable.Creator&lt;Estudiante&gt; CREATOR
    = new Parcelable.Creator&lt;Estudiante&gt;() {
        public Estudiante createFromParcel(Parcel in) {
            return new Estudiante(in);
        }</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    public Estudiante[] newArray(int size) {
        return new Estudiante[size];
    }
};
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">Ahora veis como añadir un constructor que recibe un Parcel era buena idea para tener todo limpito. Además, nota importante, cuando leemos del Parcel no hay pares clave-valor, así que hay que **leerlo en el mismo orden en que lo escribimos**.

¡Pues ya tenemos nuestro objeto implementado! Vamos a ver si funciona. Creamos un par de activities, en el primero creamos un par de estudiantes, uno amigo del otro (¡no es un amistad mutua así que sin referencias cruzadas por favor!) y lo metemos en los extras de un intent que viajarán a la segunda activity donde rescatamos nuestro estudiante y escribimos en el LogCat toda la info que hemos recibido de él y de su amigo no correspondido:

**MainActivity.java**
</code></pre></div>
<p>Estudiante otroEstudiante = new Estudiante();
otroEstudiante.nombreCompleto = &quot;Perico Palotes&quot;;
otroEstudiante.esHijoUnico = false;
otroEstudiante.fechaNacimiento = 1990;
otroEstudiante.notas = new float[]{7.8f, 4.9f, 10.0f};
otroEstudiante.amigos = new ArrayList&lt;Estudiante&gt;();</p>

<p>Estudiante estudiante = new Estudiante();
estudiante.nombreCompleto = &quot;Fernando F. Gallego&quot;;
estudiante.esHijoUnico = true;
estudiante.fechaNacimiento = 1983;
estudiante.notas = new float[]{9.5f, 8.6f, 4.6f};
estudiante.amigos = new ArrayList&lt;Estudiante&gt;();</p>

<p>estudiante.amigos.add(otroEstudiante);</p>

<p>Intent intent = new Intent(this, DestActivity.class);
intent.putExtra(&quot;estudiante&quot;, estudiante);
startActivity(intent);
```</p>

<p><strong>DestActivity.java</strong>
```
Estudiante estudiante = getIntent().getParcelableExtra(&quot;estudiante&quot;);</p>

<p>Log.i(&quot;estudiante&quot;, estudiante.nombreCompleto);
Log.i(&quot;estudiante&quot;, String.valueOf(estudiante.esHijoUnico));
Log.i(&quot;estudiante&quot;, String.valueOf(estudiante.fechaNacimiento));
Log.i(&quot;estudiante&quot;, Arrays.toString(estudiante.notas));
Estudiante amigo = estudiante.amigos.get(0);
Log.i(&quot;amigo&quot;, amigo.nombreCompleto);
Log.i(&quot;amigo&quot;, String.valueOf(amigo.esHijoUnico));
Log.i(&quot;amigo&quot;, String.valueOf(amigo.fechaNacimiento));
Log.i(&quot;amigo&quot;, Arrays.toString(amigo.notas));</pre> Y esto es lo que veremos en nuestro querido LogCat <pre class="brush: bash;">I/estudiante(6739): Fernando F. Gallego
I/estudiante(6739): true
I/estudiante(6739): 1983
I/estudiante(6739): [9.5, 8.6, 4.6]
I/amigo(6739): Perico Palotes
I/amigo(6739): false
I/amigo(6739): 1990
I/amigo(6739): [7.8, 4.9, 10.0]
```</p>

<p>Puedes descargarte el <a href="https://github.com/ferdy182/Android-parcelable-example" title="ferdy182 en GitHub Android parcelable example">código de ejemplo de github</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/04/primeros-pasos-con-ormlite/">
        Primeros pasos con ORMLite
      </a>
    </h1>

    <span class="post-date">04 Dec 2012</span>

    <p><img src="http://androcode.es/wp-content/uploads/2015/02/orm_cz4tqf.png" alt=""></p>

<p>En este blog ya os hemos hablado de cómo facilitar el trabajo con bases de datos <a href="http://androcode.es/tag/sqlite/">SQLite</a>. En concreto hemos visto cómo trabajar con <a href="http://androcode.es/tag/android-dataframework/">Android DataFramework</a> y <a href="http://androcode.es/tag/ada-framework/">ADA Framework</a>. Hoy os traemos una pequeña joya, una librería que en mis proyectos se ha convertido en una fija, ya no sólo por su facilidad de uso sino también por su potencia. Os estoy hablando de <a href="http://ormlite.com/">ORMLite</a>.   ORMLite es de esas librerías que al principio pueden resultar poco vistosas con una página poco cuidada y una documentación difícil de leer. Pero cuando trabajas con ella descubres lo fiable que es y la cantidad de posibilidades que ofrece. Sobra decir que ORMLite es una librería ORM clásica que nos permite mapear clases Java con tablas en la base de datos. En esta entrada veremos qué nos hace falta en nuestro proyecto para empezar a utilizar la librería, cómo modelar las clases, cómo crear nuestro <em>helper</em> y por último algunos ejemplos sencillos.  </p>

<h4>Elementos necesarios</h4>

<p>Lo primero que tenemos que tener es un proyecto android. ORMLite se distribuye a partir de dos librerías JAR que debemos incluir en el directorio libs de nuestro proyecto: ormlite-core: Núcleo de la librería ormlite-android: Clases específicas de android Debemos incluir ambas en nuestro proyecto y para descargarlas tenemos varias opciones:</p>

<ul>
<li><a href="http://ormlite.com/releases/">Repositorio local</a></li>
<li><a href="http://repo1.maven.org/maven2/com/j256/ormlite/">Repositorio de maven</a></li>
<li><a href="https://sourceforge.net/projects/ormlite/files/releases/com/j256/ormlite/">Sourceforge</a></li>
</ul>

<h4>Modelar las clases</h4>

<p>El siguiente paso es elegir las clases del modelo que queremos mapear a tablas en nuestra base de datos. Cada clase será una tabla en nuestra base de datos y lo indicaremos a través de anotaciones sobre la clase. Lo mejor es verlo a través de un ejemplo, para ello supongamos que tenemos dos clases, Usuario y Grupo, que representan a usuarios y grupos respectivamente. Un usuario sólo puede estar en un grupo y el grupo puede tener más de un usuario. La clase Usuario tendría la siguiente forma:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">package es.androcode.androcode_ormlite;

import java.util.Date;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable
public class Usuario {

    public static final String ID = &quot;_id&quot;;
    public static final String NOMBRE = &quot;nombre&quot;;
    public static final String FECHA_NACIMIENTO = &quot;fecha_nacimiento&quot;;
    public static final String GRUPO = &quot;grupo&quot;;

    @DatabaseField(generatedId = true, columnName = ID)
    private int id;
    @DatabaseField(columnName = NOMBRE)
    private String nombre;
    @DatabaseField(columnName = FECHA_NACIMIENTO)
    private Date fechaNacimiento;
    @DatabaseField(foreign = true, columnName = GRUPO)
    private Grupo grupo;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public Date getFechaNacimiento() {
        return fechaNacimiento;
    }

    public void setFechaNacimiento(Date fechaNacimiento) {
        this.fechaNacimiento = fechaNacimiento;
    }

    public Grupo getGrupo() {
        return grupo;
    }

    public void setGrupo(Grupo grupo) {
        this.grupo = grupo;
    }

}
</code></pre></div>
<p>Vamos a ir desgranando las principales partes importantes de este código.</p>

<p><strong>Línea 8 - Anotación DatabaseTable:</strong>
Mediante esta anotación estamos indicando que esta clase tendrá su correspondiente tabla en la base de datos. Esta anotación acepta el atributo tableName que permite indicar un nombre concreto de la tabla.</p>

<p><strong>Líneas 11 a 14:</strong>
Constantes para especificar los nombres de las columnas. Esta es una práctica que suelo utilizar a menudo y que recomiendo encarecidamente. Esto suele resultar muy útil porque más adelante necesitaremos el nombre de la columna para ordenar o realizar consultas y no es aconsejable poner las cadenas en cada uso.</p>

<p><strong>Línea 16 - DatabaseField(generatedId = true, columnName = ID):</strong>
Esta anotación se sitúa sobre el campo que hace de clave primaria. El campo puede ser de cualquier tipo, pero se aconseja que sea de tipo int o tipo long. Hemos usado <strong>generatedId</strong> para indicar que el id se genere automáticamente al crear objetos. Podríamos haber puesto <strong>generateIdSequence</strong> para que se autogenere mediante secuencia de base de datos o <strong>id</strong>, si quisiéramos indicar nosotros el id. El segundo parámetro es columnName que indica el nombre de la columna. Otra recomendación es utilizar como nombre de columna para el id &quot;_id&quot;, ya que es lo recomendado por android y nos facilitará compatibilidades con los CursorAdapter por ejemplo.</p>

<p><strong>Líneas 18 a 21:</strong>
Definición del resto de propiedades y columnas.</p>

<p><strong>Línea 22 - @DatabaseField(foreign = true, columnName = GRUPO):</strong>
Definimos la relación con la entidad Grupo, indicado mediante el atributo foreign. A través de este valor, estamos diciéndole al motor de ORMLite que la propiedad grupo hace referencia a otra entidad con su correspondiente id. La entidad Grupo es muy simple, ya que para este ejemplo no vamos a guardar relación con Usuario.  
```
package es.androcode.androcode_ormlite;</p>

<p>import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;</p>

<p>@DatabaseTable
public class Grupo {</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static final String ID = &quot;_id&quot;;
public static final String NOMBRE = &quot;nombre&quot;;

@DatabaseField(generatedId = true, columnName = ID)
private int id;
@DatabaseField(columnName = NOMBRE)
private String nombre;

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getNombre() {
    return nombre;
}

public void setNombre(String nombre) {
    this.nombre = nombre;
}
</code></pre></div>
<p>}
```</p>

<h4>Creando el helper</h4>

<p>Siempre que queramos trabajar con SQLite en Android tendremos que crear un <em>helper</em>. Una clase helper se encarga de crear, actualizar y proporcionar acceso a la base de datos. En ORMLite tendremos que extender de <strong>OrmLiteSqliteOpenHelper</strong>. También le añadiremos el acceso a los DAO para que podamos utilizarlos desde otras partes del código. Vamos a ver cómo quedaría nuestra clase <em>helper</em> y luego explicaremos las partes más importantes.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">package es.androcode.androcode_ormlite;

import java.sql.SQLException;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;

import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;
import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

public class DBHelper extends OrmLiteSqliteOpenHelper {

    private static final String DATABASE_NAME = &quot;androcode_ormlite.db&quot;;
    private static final int DATABASE_VERSION = 1;

    private Dao&lt;Usuario, Integer&gt; usuarioDao;
    private Dao&lt;Grupo, Integer&gt; grupoDao;

    public DBHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {
        try {
            TableUtils.createTable(connectionSource, Usuario.class);
            TableUtils.createTable(connectionSource, Grupo.class);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {
        onCreate(db, connectionSource);
    }

    public Dao&lt;Usuario, Integer&gt; getUsuarioDao() throws SQLException {
        if (usuarioDao == null) {
            usuarioDao = getDao(Usuario.class);
        }
        return usuarioDao;
    }

    public Dao&lt;Grupo, Integer&gt; getGrupoDao() throws SQLException {
        if (grupoDao == null) {
            grupoDao = getDao(Grupo.class);
        }
        return grupoDao;
    }

    @Override
    public void close() {
        super.close();
        usuarioDao = null;
        grupoDao = null;
    }

}
</code></pre></div>
<p><strong>Líneas 18 y 19:</strong>
Declaramos los DAO. A través de estos objetos realizaremos todas las operaciones de la base de datos. Cada objeto del modelo tiene su propio DAO asociado.</p>

<p><strong>Líneas 21 a 23:</strong>
El constructor recibe la versión de la base de datos y el nombre de la base de datos. Esta parte es común al resto de <em>helpers</em>. Existen formas de acelerar el proceso de creación de las tablas, pero es algo que veremos más adelante.</p>

<p><strong>Líneas 25 a 33:</strong>
Es el método onCreate que se encarga de crear las tablas. En este caso hacemos del método TableUtils.createTable de la API de ORMLite. Recibe como parámetro la conexión y la clase del modelo para la que crear la tabla. Como vemos esto resulta muy cómodo, mucho más si lo comparamos con tener que crear las tablas a mano.</p>

<p><strong>Líneas 35 a 38:</strong>
Método onUpgrade. En este caso al ser la primera versión de la base de datos no necesitamos actualizarla. Aquí tendríamos que poner el código encargado de actualizar la base de datos de una versión a otra tal y como lo hacemos con los helpers de android.</p>

<p><strong>Líneas 40 a 52:</strong>
Son los métodos a través de los que podemos recuperar los DAO. Estos métodos crearán el DAO si no está inicializado o lo devolverán si ya está creado.</p>

<p><strong>Línea 54 a 59:</strong>
Método close que se encarga de liberar los recursos.  </p>

<h4>Ejemplo de uso</h4>

<p>Lo primero que tenemos que plantearnos es, ¿cómo recupero el <em>helper</em>?. Los <em>helpers</em> suelen estar en el ámbito de las actividades, de forma que los fragments pueden tener acceso a través de la actividad que lo ha creado. También pueden utilizarse en servicios u otros elementos. La forma de crear el <em>helper</em> es la siguiente:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">DBHelper helper = OpenHelperManager.getHelper(context, DBHelper.class);
</code></pre></div>
<p>Llamamos al método <strong>OpenHelperManager.getHelper</strong> pasándole como argumentos el contexto y la clase antes definida. Es importante liberar recursos una vez que no vayamos a hacer operaciones con la base de datos. En el caso de las actividades podemos realizar esto en el método <strong>onDestroy</strong>. En las actividades en las que vayamos a necesitar acceso al helper suelo utilizar el siguiente trozo de código (puedes moverlo a una clase abstracta y extender de ella si tienes más de una actividad con acceso a base de datos).  </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private DBHelper mDBHelper;

    private DBHelper getHelper() {
        if (mDBHelper == null) {
            mDBHelper = OpenHelperManager.getHelper(this, DBHelper.class);
        }
        return mDBHelper;
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mDBHelper != null) {
            OpenHelperManager.releaseHelper();
            mDBHelper = null;
        }
    }
</code></pre></div>
<p>Resumiendo, creamos una propiedad para almacenar la referencia a DBHelper y nos creamos un método de acceso para inicializar la clase sólo cuando haga falta. Observa que si nunca accedemos a dicho método, nunca inicializaremos la clase DBHelper. Por último se añade al método <strong>onDestroy</strong> la liberación de recursos. Ahora vamos a ver algunos ejemplos sencillos de cómo interactuar con la base de datos. Como veremos a continuación, los métodos de los DAO pueden lanzar SQLException. ORMLite siempre nos ofrece mucha flexibilidad y en este caso no iba a ser menos. Si nos sentimos incómodos capturando en cada trozo de código en el que hagamos operaciones con base de datos simplemente cambiamos el uso de la clase Dao por RuntimeExceptionDao. Las excepciones que lanza RuntimeExceptionDao son de tipo <em>runtime</em>, por lo que no es necesario capturarlas. De todas formas no os aconsejo esto último, porque si falla una operación en la base de datos tendréis que actuar en consecuencia y no simplemente dejar que la aplicación de un <em>force close</em> al usuario.</p>

<p><strong>Crear un objeto</strong>  
<code>
Dao dao;
try {
    dao = getHelper().getUsuarioDao();
    Usuario usuario = new Usuario();
    usuario.setFechaNacimiento(new Date());
    usuario.setNombre(&quot;Fede&quot;);
    dao.create(usuario);
} catch (SQLException e) {
    Log.e(TAG, &quot;Error creando usuario&quot;);
}
</code></p>

<p><strong>Recuperar objetos</strong>  
<code>
Dao dao;
try {
    dao = getHelper().getUsuarioDao();
    Usuario usuario = dao.queryForId(1);
    if (usuario == null) {
        Log.d(TAG, &quot;Ningún usuario con id = 1&quot;);
    } else {
        Log.d(TAG, &quot;Recuperado usuario con id = 1: &quot; + usuario.getNombre());
    }
    List usuarios = dao.queryForEq(Usuario.NOMBRE, &quot;Fede&quot;);
    if (usuarios.isEmpty()) {
        Log.d(TAG, &quot;No se encontraron usuarios con nombre = Fede&quot;);
    } else {
        Log.d(TAG, &quot;Recuperado usuarios con nombre = Fede &quot; + usuarios);
    }
} catch (SQLException e) {
    Log.e(TAG, &quot;Error creando usuario&quot;);
}
</code></p>

<p>El objeto DAO permite realizar consultas simples. Para consultas más complejas tendremos utilizar un QueryBuilder. A continuación podemos ver un ejemplo sencillo. En una próxima entrada veremos usos más avanzados de consultas.  </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Dao dao;
try {
    dao = getHelper().getUsuarioDao();
    QueryBuilder queryBuilder = dao.queryBuilder();
    queryBuilder.setWhere(queryBuilder.where().eq(Usuario.NOMBRE, &quot;Fede&quot;));
    List usuarios = dao.query(queryBuilder.prepare());
    if (usuarios.isEmpty()) {
        Log.d(TAG, &quot;No se encontraron usuarios con nombre = Fede&quot;);
    } else {
        Log.d(TAG, &quot;Recuperado usuarios con nombre = Fede &quot; + usuarios);
    }
} catch (SQLException e) {
    Log.e(TAG, &quot;Error creando usuario&quot;);
}
</code></pre></div>
<p><strong>Actualizar y eliminar objetos</strong>  
<code>
Dao dao;
try {
    dao = getHelper().getUsuarioDao();
    usuario.setNombre(&quot;Pedro&quot;);
    dao.update(usuario);
    Log.d(TAG, &quot;Usuario modificado: &quot; + usuario.getNombre());
    dao.delete(usuario);
} catch (SQLException e) {
    Log.e(TAG, &quot;Error creando usuario&quot;);
}
</code></p>

<h4>Conclusiones</h4>

<p>Como podéis ver ORMLite es muy sencillo e intuitivo. En próximas entradas intentaremos profundizar en su uso. También os recomendaría que os dierais una vuelta por la <a href="http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite.html">documentación oficial</a> y por supuesto a las preguntas y respuestas sobre esta librería en <a href="http://stackoverflow.com/questions/tagged/ormlite">stackoverflow</a>.</p>

  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Más antiguas</span>
  
  
    
      <a class="pagination-item newer" href="/page2">Más nuevas</a>
    
  
</div>

    </div>

  </body>
</html>
