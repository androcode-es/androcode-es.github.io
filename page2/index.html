<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Inicio &middot; Androcode
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface|Roboto+Condensed:bold">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-androcode">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          <img class="sidebar-logo" src="/public/logo_white_100w.png" />
          Androcode
        </a>
      </h1>
      <p class="lead">Androcode es programación, Androcode es tecnología, Androcode necesita una descripción nueva.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Inicio</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">¿Quiénes somos?</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/androteca/">La Androteca</a>
          
        
      
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    </nav>

    <nav class="sidebar-social">
      <ul class="navigation">

        <li class="social-item twitter">
          <a href="http://twitter.com/@androcode" title="@androcode on Twitter" target="_blank">
            <i class="icon fa fa-twitter"></i>
            <span class="label">Twitter</span>
          </a>
        </li>

        <li class="social-item gplus">
          <a href="https://plus.google.com/+AndrocodeEs/posts" title="+AndrocodeEs" target="_blank">
            <i class="icon fa fa-google-plus-square"></i>
            <span class="label">Google+</span>
          </a>
        </li>

        <li class="social-item github">
          <a href="http://github.com/androcode-es" title="@androcode-es on GitHub" target="_blank">
            <i class="icon fa fa-github"></i>
            <span class="label">GitHub</span>
          </a>
        </li>
      </ul>
    </nav>

    <p class="sidebar-foot-note">&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/02/21/otra-forma-de-acelerar-el-emulador-de-android/">
        Otra forma de acelerar el emulador de Android
      </a>
    </h1>

    <span class="post-date">21 Feb 2014</span>

    <p>Por muchos es sabido que el emulador de android que viene con el SDK deja mucho que desear. Afortunadamente existen alternativas como usar <a href="http://androcode.es/2011/10/aumenta-la-velocidad-del-emulador-de-android-en-un-400/" title="Aumenta la velocidad del emulador de Android en un 400%">android-x86 y virtualbox para virtualizar un dispositivo android </a>como vimos anteriormente. Pero hoy voy a contaros otra forma, disponible desde hace un tiempo, que también está basado en virtualización pero está mejor integrado con el entorno de desarrollo como puede ser Eclipse. En este caso vamos a usar la virtualización existente en los procesadores Intel, y una imagen de disco de android para x86, también provista por intel a través del SDK Manager de Android, de forma que convierte este proceso en algo fácil y rápido.</p>

<h6>Requisitos:</h6>

<ul>
<li>Procesador con Intel que soporte Intel VT-x, EM64T y Execute Disable(XD) Bit habilitado en la BIOS.</li>
<li>Tener instalado el <a href="https://developer.android.com/sdk/index.html" title="Android SDK">SDK de Android.&lt;!--more--&gt;</a></li>
</ul>

<h6>Instalación en Windows</h6>

<p>Una vez instalado el SDK de Android, abrimos el SDK Manager que usamos para descargarnos las diferentes versiones de Android y marcamos para descargar el Intel HAXM dentro de la pestaña de &quot;extras&quot;. Aunque lo instalemos desde el SDK Manager en realidad sólo nos copia un instalador a la carpeta &quot;extras&quot; donde está instalado el SDK de Android, así que vamos a ésa carpeta de nuestro disco duro e instalamos IntelHaxm.exe. Otra cosa que debemos marcar para instalar es la Intel x86 Atom System Image de la versión de Android que deseemos, de esta manera podremos crear AVDs con esta imagen del sistema.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/intel_haxm_1_nufouv.png"><img src="http://androcode.es/wp-content/uploads/2015/02/intel_haxm_1_nufouv.png" alt="intel_haxm_1"></a><a href="http://androcode.es/wp-content/uploads/2015/02/ScreenShot017_ho8kzb.png"><img src="http://androcode.es/wp-content/uploads/2015/02/ScreenShot017_ho8kzb.png" alt="Intel HAXM.exe"></a></p>

<p>Ejecutamos el instalador y seguimos los pasos. En caso de que nuestra BIOS no tenga configurada la opción de VT-x deberemos arrancar la BIOS, para activarla más o menos así, y luego volver a instalar el Intel HAXM:</p>

<p><a href="http://software.intel.com/sites/default/files/haxm07.jpg"><img src="http://software.intel.com/sites/default/files/haxm07.jpg" alt=""></a></p>

<h6>Crear el AVD</h6>

<p>Una vez instalado el SDK y el Intel HAXM, procederemos a crear un dispositivo android virtual, para ello abrimos el AVD Manager y creamos un AVD nuevo.</p>

<p>Deberemos elegir un target del que nos hayamos bajado su imagen Intel x86 como hemos hecho en el paso anterior con el SDK Manager, así podremos elegir, en CPU/ABI, la opción Intel Atom (x86).</p>

<p>Ponemos un nombre y elegimos un dispositivo cualquiera.</p>

<p>Importante seleccionar &quot;Use Host GPU&quot; para que utilice OpenGL para el renderizado, de esta manera la parte gráfica irá más rápida. Una vez hecho todo esto, hacemos click en OK, para generar el AVD y luego una vez creado, pulsamos en Start y arrancamos el emulador. Debería tardar sólo 15 segundos y debemos ver un mensaje de que está arrancando en &quot;fast virtual mode&quot;</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/intel_haxm_3_ywl9tw.png"><img src="http://androcode.es/wp-content/uploads/2015/02/intel_haxm_3_ywl9tw.png" alt="intel_haxm_3"></a></p>

<p>Una vez hecho esto, podemos instalar y probar nuestra aplicación en el emulador e incluso controlar algunos aspectos como la ubicación GPS, simular recibir llamadas o mensajes, etc. desde la pestaña &quot;Emulator control&quot; de la perspectiva &quot;DDMS&quot; (En Eclipse: Window &gt; Open perspective &gt; DDMS).</p>

<p>Para más información, resolución de problemas y cómo instalarlo en Linux, podéis leer <a href="http://software.intel.com/en-us/android/articles/speeding-up-the-android-emulator-on-intel-architecture#_Toc358213274" title="Intel HAXM">este artículo de la página de Intel</a> que lo explica con más detalle.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/27/usar-codigos-secretos-en-tu-aplicacion/">
        Usar códigos secretos en tu aplicación
      </a>
    </h1>

    <span class="post-date">27 Nov 2013</span>

    <p><a href="http://androcode.es/wp-content/uploads/2015/02/androcode_secret_code_rmtwnf.png"><img src="http://androcode.es/wp-content/uploads/2015/02/androcode_secret_code_rmtwnf.png" alt="androcode_secret_code"></a></p>

<p>Estoy seguro de que todos habréis usado alguna vez un &quot;código secreto&quot; en vuestro móvil. Son los códigos que al introducirlos en el teclado del &quot;teléfono&quot; (el de llamar, que los smartphones también hacen eso, eh) permiten acceder a alguna función especial, como ver el IMEI <em>(*#06#)</em> o información del teléfono <em>(<em>#</em>#4636#<em>#</em>)</em>. Pero no queda ahí la cosa, porque podemos crear nuestros propios códigos, y vamos a ver cómo.</p>

<h6>¿De dónde viene esto?</h6>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/protips_original_recorte_bg3m30.png"><img src="http://androcode.es/wp-content/uploads/2015/02/protips_original_recorte_bg3m30.png" alt="protips_original_recorte"></a></p>

<p>Bueno, de dónde viene realmente no lo sé, pero sí os diré cómo me enteré yo de su existencia. Hace unos (muchos) meses estaba preparando un teléfono viejo para dárselo a alguien, ya sabéis, configurar algunas cosas e instalar aplicaciones básicas. Como tenía versión 2.3, sin duda le puse en la pantalla principal el widget de bienvenida que traía Android por aquel entonces, ¿lo recordáis? Pero tuve una mejor idea: modificar el widget para poner consejos y mensajes más personales. Así de detallista soy :p. Así que me bajé el <a href="https://android.googlesource.com/platform/packages/apps/Protips/+/master">código fuente</a> (gracias, Open Source), me creé un proyecto con él y empecé a cambiar cosas. Sorpresa la mía al ver en el AndroidManifest.xml un Intent-Filter que no había visto antes:</p>

<!--more-->

<pre class="brush: xml; gutter: true; first-line: 1">&lt;receiver android:name=".ProtipWidget" android:label="@string/widget_name"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;
                &lt;action android:name="com.android.protips.NEXT_TIP" /&gt;
                &lt;action android:name="com.android.protips.HEE_HEE" /&gt;
            &lt;/intent-filter&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.provider.Telephony.SECRET_CODE" /&gt;
                &lt;data android:scheme="android_secret_code" android:host="8477" /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_build" /&gt;
        &lt;/receiver&gt;</pre>

<p>Ese <em>android.provider.Telephony.SECRET</em>CODE_ es bastante llamativo, ¿no? Con el número 8477 (que corresponde al <a href="http://es.wikipedia.org/wiki/Phonewords"><em>Phoneword</em></a> de &quot;TIPS&quot;) en los datos y la acción perteneciente al paquete Telephony, no hay que ser un genio para deducir que ese código se introduce en el marcador del teléfono. Lo hice y... Voilà! Los consejos del widget cambiaron por completo:</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/protips__secret_vyez3e.png"><img src="http://androcode.es/wp-content/uploads/2015/02/protips__secret_vyez3e.png" alt="protips__secret" title="Gracias por las capturas, mi viejo HTC Legend :)"></a></p>

<p>¡Toma huevo de pascua! Como veis, al introducir el código los consejos originales cambian por unos en tono más de humor. Y como de costumbre en Android, si el widget puede nosotros también.</p>

<p>¿Por qué os cuento esto? Pues para que sirva de moraleja: <strong>leyendo código fuente</strong>, tanto de Android como de otros proyectos, <strong>se aprende mucho</strong>.</p>

<h6>Déjate de rollos, cómo se hace</h6>

<p>El funcionamiento de los códigos secretos propios no tiene misterio. En el anterior extracto de manifiesto tenéis la mitad del trabajo hecho. Sólo hay que añadir un Intent-Filter a nuestro AndroidManifest.xml con la acción android.provider.Telephony.SECRET<em>CODE, y con la especificación de esquema &quot;android</em>secret_code&quot; y nuestro número secreto como host. Hay que tener en cuenta que estos códigos se introducen en el dialer en formato <em>#</em>#código#<em>#</em>, pero nosotros aquí sólo especificamos el número.</p>

<p>La segunda parte es añadir el elemento que recibe ese Intent. Podría ser cualquiera, por ejemplo una Activity o un Broadcast Receiver que active cierta función en la aplicación. Una implementación básica podría ser:
<pre class="brush: java; gutter: true; first-line: 1">public class SecretCodeReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(&quot;android.provider.Telephony.SECRET<em>CODE&quot;)) {
            String numero = intent.getData().getHost();
            if (numero.equals(&quot;732738&quot;)) {
                Toast.makeText(context, &quot;¡Función chachipiruli altamente secreta desbloqueada!&quot;, Toast.LENGTH</em>SHORT).show();
            } else {
                // Podemos usar el mismo receiver para otros códigos distintos
            }
        }
    }
}</pre>
Y listo. Por supuesto las posibilidades no acaban aquí. Ya sabéis lo versátiles que son los Intents, así que posibilidades de explotar esta pequeña función hay infinitas. A mí se me ocurren varias aparte de los huevos de pascua y pantallas ocultas. ¿Y a vosotros? ¿Para qué usaríais los códigos secretos? ¿Los conocíais ya?</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/04/19/generar-id-unico-en-la-instalacion-de-nuestras-apps/">
        Generar ID único en la instalación de nuestras apps
      </a>
    </h1>

    <span class="post-date">19 Apr 2013</span>

    <p>Hace poco tuve que pelearme con la generación de un ID único para el dispositivo o la instalación que estoy ejecutando de mi aplicación y tras buscar mucho por Internet encontré varias opciones pero siempre con algún inconveniente que hacía imposible su uso real.</p>

<p>Las distintas opciones que encontré <em>(y sus inconvenientes)</em> son estas:</p>

<ul>
<li><em>IMEI:</em> Sólo disponible en dispositivos con SIM disponible. Necesita declarar permiso en el manifest.</span></li>
<li><em>Secure.ANDROID_ID:</em> Sólo existe desde Android 2.2 y con posibles valores duplicados entre dispositivos.</li>
<li><em>MAC del WiFi/BT:</em> Sólo funciona si está activo el receptor. Necesitamos pedir permiso en el manifest.</li>
<li><em>Build.SERIAL:</em> Disponible a partir de Android 2.3. Sólo obligatorio para dispositivos sin SIM.
Como podéis ver no hay nada que directamente nos identifique el dispositivo o la instalación de forma única y, por tanto, que podamos usar como ID de la misma.</li>
</ul>

<p>Tras mucho pelearme me crucé con un snippet de código que Reto Meier indicó en el Google I/O de 2011 como mejor aproximación para obtener dicha identificación y que no tiene ninguno de los inconvenientes que sí veíamos en las opciones anteriores.</p>

<!--more-->

<p>El snippet en concreto es este que os copio aquí debajo y que podéis pegar en cualquier clase de vuestro proyecto directamente ya que no necesita ningún permiso especial a declarar en el manifest y es compatible incluso con Android 1.0...</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private static String uniqueID = null;
private static final String PREF_UNIQUE_ID = &quot;PREF_UNIQUE_ID&quot;;

public synchronized static String id(Context context) {
    if (uniqueID == null) {
        SharedPreferences sharedPrefs = context.getSharedPreferences(PREF_UNIQUE_ID, Context.MODE_PRIVATE);
        uniqueID = sharedPrefs.getString(PREF_UNIQUE_ID, null);
        if (uniqueID == null) {
            uniqueID = UUID.randomUUID().toString();
            Editor editor = sharedPrefs.edit();
            editor.putString(PREF_UNIQUE_ID, uniqueID);
            editor.commit();
        }
    }
    return uniqueID;
}
</code></pre></div>
<p>Y para obtener el código desde cualquier punto de nuestro proyecto tan solo debemos llamar al método <em>id()</em> pasándole un objeto de tipo <em>Context</em>, por ejemplo:
<pre class="brush: java; gutter: true; first-line: 1">String deviceID = id(Activity.this);</pre>
Y hasta aquí este pequeño snippet que seguro le dais un buen uso... ;)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/02/14/como-hacer-mas-comodo-el-trabajo-con-eclipse/">
        Hacer más cómodo el trabajo con Eclipse
      </a>
    </h1>

    <span class="post-date">14 Feb 2013</span>

    <p>Lo parezca o no, trabajar cómodo con nuestro entorno de desarrollo es muy importante de cara a la productividad. Es por eso que nos cuesta tanto cambiarnos a otro IDE cuando estamos acostumbrados a uno concreto. Nos sentimos perdidos, todo lo que es diferente nos parece peor. Porque no hay nada como escribir código cómodamente.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/eclipse_indigo_sf5siq.png"><img src="http://androcode.es/wp-content/uploads/2015/02/eclipse_indigo_sf5siq.png" alt="eclipse_indigo"></a></p>

<p>El post de hoy no es tan exclusivo para el desarrollo Android, pero como también nos afecta a nosotros me ha parecido bien tratarlo. Vamos a ver algunos trucos y consejos para escribir código aún más fácilmente, si estamos usando Eclipse.&lt;!--more--&gt;</p>

<p>Todo lo que se comenta en esta entrada son opiniones a título personal y como orientación Para gustos colores, si no te parecen buenos consejos o tienes otros mejores, cuéntanoslo en los comentarios ;)</p>

<blockquote>
<p>Utilizaré como base el ADT Bundle para Windows que tenemos disponible en la página de desarrolladores, que contiene el SDK y una versión modificada de Eclipse 3.6 con la configuración básica para empezar a desarrollar aplicaciones Android.</p>
</blockquote>

<h6>Preparación del entorno</h6>

<p>Lo primero que vamos a ver son algunos cambios en la configuración de Eclipse que podemos hacer para facilitarnos el trabajo. Aunque opciones hay muchas, éstas son las que me han parecido más útiles. Mi <em>&quot;must have&quot;</em> personal, lo primero que tengo que cambiar si hago una instalación nueva.</p>

<h6>Cambiar la codificación de caracteres</h6>

<p>Es un tema por el que me he echado las manos a la cabeza más de una vez. Y más de dos, y de trés... Trabajar con diferentes codificaciones es un infierno, sólo causará problemas. Eclipse por defecto en Windows utiliza una codificación, en Linux otra, y en OSX otra distinta. Si trabajas siempre en la misma máquina el problema puede pasar desapercibido, pero en cuanto migras un proyecto de sistema, se lo pasas a alguien, etc. verás como los caracteres especiales se han convertido en símbolos extraños.</p>

<p>Los angloparlantes no suelen tener graves problemas con esto, pues la mayoría de codificaciones <em>respetan</em> sus símbolos. Pero nosotros, con tanta tilde y símbolo raro, vamos a encontrarnos en apuros. Lo mejor es curarse en salud y cambiar desde un principio la codificación de todo el workspace, en el menú bajo Window &gt; Preferences,  a una universal como UTF-8. </p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/codificacion_twaypa.png"><img src="http://androcode.es/wp-content/uploads/2015/02/codificacion_twaypa-300x258.png" alt="codificacion"></a></p>

<p>Si lo hacéis no me lo agradeceréis porque no os daréis cuenta de que os ha servido. Pero si no, ya os arrepentiréis.  ;-)</p>

<h6>Desactivar <em>compilado automático</em> y <em>compilar todo</em></h6>

<p>Por defecto Eclipse tiene activada la opción de compilar automáticamente nuestro proyecto cuando guardamos algún archivo modificado. Esto es especialmente problemático en Android cuando tenemos proyectos relativamente complejos, con varias librerías externas vinculadas y demás compilar puede llevar varios segundos o peor en ordenadores con pocos recursos (¿he oído minutos?). Y no es agradable que nos interrumpan el trabajo sólo por guardar los cambios. Por ello es de lo primero que desactivo cuando abro Eclipse por primera vez. Sólo hay que desmarcar la opción en Project &gt; Build Automatically.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/build_s0orgi.png"><img src="http://androcode.es/wp-content/uploads/2015/02/build_s0orgi-300x153.png" alt="build"></a></p>

<p>Aunque desactivando dicha opción tenemos el <del>problema</del> inconveniente de tener que compilar manualmente cuando lo necesitemos. Por suerte tenemos el atajo de teclado <strong>Ctrl+B</strong> para hacerlo a golpe de tecla, pero este atajo corresponde al comando <em>Build All</em>, es decir que nos compilará todos los proyectos de nuestro workspace. ¡Aún peor que lo anterior! Don&#39;t panic, es tan fácil como cambiar el atajo para que ejecute el comando <em>Build Project</em> en su lugar, de esa forma la combinación te teclas sólo compilará el proyecto en el que nos encontremos en ese momento. En el apartado Keys de las preferencias buscamos el comando <em>Build All</em> y le anulamos el atajo de teclado con <strong>Unbind Command</strong>, luego seleccionamos <em>Build Project</em> y en Binding pulsamos la combinación Ctrl+B (u otra) para establecérsela.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/build3_asmolf.png"><img src="http://androcode.es/wp-content/uploads/2015/02/build3_asmolf-300x215.png" alt="build3"></a></p>

<p>Aunque para ejecutar no suele hacer falta compilar porque ya lo hace solo, ya sabemos cómo se pone de tonto a veces Eclipse. Es uno de los comandos que yo más utilizo.</p>

<h6>Desactivar corrección ortográfica</h6>

<p>Curiosamente Eclipse tiene corrector ortográfico para los comentarios y documentación. Pero a los hispanohablantes no nos sirve de mucho si escribimos en español porque sólo está en inglés. Podríamos descargar e instalar un diccionario en español, pero yo prefiero optar por desactivarlo por completo y quitarme las molestas líneas rojas que salen por todas partes.</p>

<p><a href="http://res.cloudinary.com/dttcwxrjo/image/upload/v1422989312/spelling_dsdejb.png"><img src="http://res.cloudinary.com/dttcwxrjo/image/upload/h_235,w_300/v1422989312/spelling_dsdejb.png" alt="spelling"></a></p>

<h6>Explorador de paquetes en vista jerárquica</h6>

<p>El explorador de paquetes nos permite 2 formas básicas de visualizarlos: <strong>plana</strong> y** jerárquica**. Por defecto nos los muestra de forma plana, pero cuando tenemos muchos paquetes anidados la jerárquica permite verlos más claramente con su estructura de árbol. ¿No os parece?</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/package_xzre6q.png"><img src="http://androcode.es/wp-content/uploads/2015/02/package_xzre6q.png" alt="package"></a></p>

<p>Podéis usar la que más os guste, en cualquier caso el cambio es sencillo.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/package3_nr4kyw.png"><img src="http://androcode.es/wp-content/uploads/2015/02/package3_nr4kyw-300x182.png" alt="package3"></a></p>

<h6>Ayuda para escribir código</h6>

<p>Ahora veremos alguno ajustes orientados a facilitarnos la escritura de código. Eclipse permite un alto nivel de personalización, pero sólo veremos unos que me parecen muy interesantes. Como antes, recomiendo echar un ojo a todas las opciones y adaptarlo todo a nuestras necesidades.</p>

<h6>Punto y coma siempre al final</h6>

<p>En java las sentencias llevan un punto y coma al final. Parece una tontería, pero son incontables las veces que he tenido que desplazarme al final de la línea para poner un punto y coma. Con este cambio Eclipse colocará la puntuación correctamente al final de la línea aunque estemos editando en mitad, ahorrándonos un par de pulsaciones de tecla.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/semicolon_d3j7on.png"><img src="http://androcode.es/wp-content/uploads/2015/02/semicolon_d3j7on-300x275.png" alt="semicolon"></a></p>

<h6>Autocompletado de métodos mejorado</h6>

<p>El autocompletado de Eclipse es magnífico. <strong>Ctrl+Espacio</strong> es la combinación que más uso con diferencia, nos ahorra escribir una barbaridad de código. Pero algo que siempre me ha reventado es cómo al completar una variable o un método desde en medio inserta el texto en vez de modificarlo.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/overwrite12_zdjdag.png"><img src="http://androcode.es/wp-content/uploads/2015/02/overwrite12_zdjdag.png" alt="overwrite12"></a></p>

<p>Pues hace poco descubrí que se podía cambiar para que sustituyera el resto del texto. De esa forma en el ejemplo anterior obtendríamos lo siguiente:</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/overwrite34_ndqvjq.png"><img src="http://androcode.es/wp-content/uploads/2015/02/overwrite34_ndqvjq.png" alt="overwrite34"></a></p>

<p>A mi me resulta muchísimo más útil la segunda transformación, y sólo hay que cambiar una opción:</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/overwrite_dhqc8k.png"><img src="http://androcode.es/wp-content/uploads/2015/02/overwrite_dhqc8k-300x275.png" alt="overwrite"></a></p>

<h6>Escapar Strings al pegar texto</h6>

<p>Copiar y pegar es el recurso más utilizado. ¿Cuántas veces hemos pegado en una cadena un texto copiado de otra parte que contiene comillas y otros caracteres que necesitan ser escapados (como las comillas en un código html)? Activando esta opción no tendremos que hacerlo más, pues el texto se transformará automáticamente cuando lo peguemos para escapar dichos caracteres.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/strings_mrdpqp.png"><img src="http://androcode.es/wp-content/uploads/2015/02/strings_mrdpqp-300x276.png" alt="strings"></a></p>

<p>Aquí vemos cómo quedaría al pegar una cadena con comillas antes y después de activar esta opción:</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/strings2_tqfznv.png"><img src="http://androcode.es/wp-content/uploads/2015/02/strings2_tqfznv.png" alt="strings2"></a></p>

<h6>Acciones al guardar</h6>

<p>Nos puede venir bien que Eclipse haga determinadas cosas automáticamente cuando guardamos un archivo. Por ejemplo, que reorganice las importaciones de paquetes, o que formatee el código según las reglas que le digamos. Debo confesar que yo personalmente lo tengo desactivado, porque tengo la manía de guardar los cambios constantemente, y al procesar el archivo cada vez puedo notar el retraso en contadas ocasiones si el ordenador está pasando un mal rato y no lo soporto. Pero aun así, si no sois tan maníacos como yo seguro que agradecéis esta función.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/save_dqpzw9.png"><img src="http://androcode.es/wp-content/uploads/2015/02/save_dqpzw9-300x276.png" alt="save"></a></p>

<h6>Formateo de código</h6>

<p>Otra de las funciones más útiles de Eclipse es el formateo de código automático, mediante la combinación de teclas <strong>Ctrl+Shift+F</strong>. Nosotros escribimos (o pegamos) un churro, con las identaciones mal puestas, espacios sobrantes, etc., y Eclipse nos deja un código limpio, claro y ordenado. Pero es importante para estar cómodos con nuestro IDE que nos produzca código que nos guste. Para ello viene bien echar unos minutos en revisar las opciones de personalización del formateo de código, que no son pocas. Podemos tener varios perfiles, e incluso configurar un perfil distinto para cada proyecto (modificando las preferencias del proyecto concreto, y no las globales). Para personalizarlos creamos uno nuevo o editamos el existente (habrá que guardarlo con otro nombre).</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/format1_kficmo.png"><img src="http://androcode.es/wp-content/uploads/2015/02/format1_kficmo-300x274.png" alt="format1"></a></p>

<p>Aquí entran muy en juego los gustos de cada uno. Aconsejo mirar todas las opciones, elegir las que nos parezcan mejores, y volver a mirarlas tras llevar un tiempo con ellas para asegurarnos de que estamos cómodos con todas.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/format2_bhouhm.png"><img src="http://androcode.es/wp-content/uploads/2015/02/format2_bhouhm-300x257.png" alt="format2"></a></p>

<p>Os comento como ejemplo las que yo suelo cambiar, que son realmente pocas: En <em>Identation</em> pongo Tab Policy a <em>Tabs Only</em>, y activo <em>Statements within switch body</em>; en <em>Line Wrapping</em> pongo el <em>Maximun line width</em> a un valor alto como 200 para que no me divida las líneas, y activo <em>Never join already wrapped lines</em> por si quiero dividirlas  manualmente; y por último en <em>Comments</em> activo <em>Never join lines</em> para decidir yo los saltos de línea, y pongo el <em>Maximun line width</em> también a un valor como 200. </p>

<p>Mucho ojo a esta función si trabajamos en grupo con repositorios, o si contribuímos a proyectos de software libre. Debemos adaptarnos a las normas comunes, así que si pensamos dejar que Eclipse formatee nuestro código debemos asegurarnos de respetar dichas normas. No queremos que Git nos marque todo el archivo &quot;en rojo&quot; cuando sólo hemos cambiado una línea, ¿verdad?</p>

<h6>Etiquetas</h6>

<p>No muy usadas, pero están ahí para ayudar a organizarnos si las necesitamos. Las etiquetas son comentarios especiales que podemos poner para marcar nuestro código. La más famosa es la etiqueta <strong>TODO</strong>, para dejar anotado algo que tenemos que hacer o cambiar en un futuro. Pero nosotros mismos podemos crear nuestras etiquetas personalizadas. Por ejemplo DEBUG para indicar algo que debemos quitar antes de sacar la aplicación a producción,  asignar tareas a determinadas personas en un grupo, etc. </p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/tags_uh9kru.png"><img src="http://androcode.es/wp-content/uploads/2015/02/tags_uh9kru-300x278.png" alt="tags"></a></p>

<p>Luego podemos ver la lista de etiquetas usadas en la vista Tasks (Si no la tenemos se activa en Window &gt; Show View &gt; Tasks)</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/tags2_neqlws.png"><img src="http://androcode.es/wp-content/uploads/2015/02/tags2_neqlws.png" alt="tags2"></a></p>

<h6>Plantillas de código</h6>

<p>Eclipse nos permite usar palabras clave para generar automáticamente determinadas estructuras de código, y más aún, crearlas a nuestro gusto. Por ejemplo, uno de los métodos más utilizados en Java es System.out.println() para imprimir texto en la consola; pues nos basta con escribir en el editor &quot;sysout&quot; y pulsar el autocompletado (ctrl+espacio) para que nos inserte la línea completa y nos ponga el cursor en la posición del argumento. Lo mismo ocurre con &quot;try&quot; para insertar un bloque try-catch.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/codtemplate12_kuk5re.png"><img src="http://androcode.es/wp-content/uploads/2015/02/codtemplate12_kuk5re.png" alt="codtemplate12"></a></p>

<p>La lista completa podemos verla en las preferencias, y ahí mismo podemos añadir nuestras propias plantillas. Por ejemplo, podríamos crear una plantilla así para inicializar el método getView() típico del BaseAdapter: </p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/codetemplates3_jgadxe.png"><img src="http://androcode.es/wp-content/uploads/2015/02/codetemplates3_jgadxe-300x261.png" alt="codetemplates3"></a></p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/codetemplates4_anikbo.png"><img src="http://androcode.es/wp-content/uploads/2015/02/codetemplates4_anikbo-1024x355.png" alt="codetemplates4"></a></p>

<p>Copiar código</p>

<p>Y en el editor de código, poniendo la palabra clave con autocompletado, nos genera el código por el que podemos movernos mediante el tabulador. ¡Magia!</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/codetemplates56_jp3ca5.png"><img src="http://androcode.es/wp-content/uploads/2015/02/codetemplates56_jp3ca5.png" alt="codetemplates56"></a></p>

<h6>Plantillas de ADT</h6>

<p>No hace mucho añadieron al plugin ADT la posibilidad de crear componentes de Android como Actividades para nuestras aplicaciones mediante un <strong>asistente</strong>, que podemos encontrar en el menú <em>File &gt; New</em> bajo la categoría de Android, el cual nos genera el código y recursos que podemos editar fácilmente. Por ejemplo, en el caso de las Actividades nos creará un <strong>layout</strong> y <strong>menú</strong> básicos en xml, la <strong>clase Java</strong> correspondiente con el código para mostrar el layout y el menú, y la entrada necesaria en el <strong>AndroidManifest.xml</strong>. E incluso podemos decirle que nos añada elementos extra de navegación como pestañas, ViewPager y más.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/templatesadt2_ogac3e.png"><img src="http://androcode.es/wp-content/uploads/2015/02/templatesadt2_ogac3e-300x284.png" alt="templatesadt2"></a></p>

<p>Por si fuera poco, un tiempo después añadieron la posibilidad de instalar plantillas personalizadas creadas por nosotros mismos. Yo os recomiendo <a href="https://github.com/jgilfelt/android-adt-templates">estas plantillas </a>creadas por Jeff Gilfelt para crear Actividades compatibles con la magnífica librería <strong><a href="http://androcode.es/2012/03/introduccion-a-actionbarsherlock/" title="Introducción a ActionBarSherlock">ActionBar Sherlock</a></strong>, entre otras. En el repositorio tenéis más información sobre para qué es cada uno de los elementos que añade. Además, instalar las plantillas es tan sencillo como pegarlas en la carpeta <strong>/extras/templates/</strong> del SDK.</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/templatesadt4_qkhxyb.png"><img src="http://androcode.es/wp-content/uploads/2015/02/templatesadt4_qkhxyb-198x300.png" alt="templatesadt4"></a></p>

<p>Tenéis más información sobre cómo crear plantillas en <a href="https://plus.google.com/113735310430199015092/posts/XTKTamk4As8">este post de Google+</a>. ¿Se os ocurren más plantillas útiles? ¿Os animáis a hacerlas y compartirlas? ;)</p>

<p>Y hasta aquí los cambios que os sugerimos para vuestro IDE, espero que algunos os resulten tan útiles como a mi. En futuras entregas intentaremos contar otros trucos a la hora de usar Eclipse. Si tenéis más sugerencias relacionadas son bienvenidas en los comentarios  ;-)</p>

<p>Fuentes: <a href="http://www.vogella.com/articles/Eclipse/article.html#preferences">Vogella</a> y cosecha propia</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/01/23/como-anadir-datos-precargados-en-tus-aplicaciones/">
        Añadir datos precargados en tus aplicaciones
      </a>
    </h1>

    <span class="post-date">23 Jan 2013</span>

    <p>Hay ocasiones en las que por alguna razón necesitamos incluir una serie de datos precargados en nuestra aplicación android, de forma que cuando el usuario instale la aplicación pueda empezar a disfrutar de contenido sin necesidad de tener que depender de un servicio externo.</p>

<p>En el siguiente artículo os plantearemos una serie de alternativas sobre cómo partir de una base de datos con datos existentes. No existe una opción única o mejor que todas, ya que cada una de las soluciones aquí presentadas se adaptan a distintas situaciones.</p>

<h5>Opción 1 - Carga manual al crear la base de datos</h5>

<p>Si los datos son pocos y éstos no van a cambiar mucho la forma más sencilla es insertarlos manualmente durante la creación de la base de datos.</p>

<p>Al trabajar con <a href="http://developer.android.com/training/basics/data-storage/databases.html">bases de datos en android</a>, tendremos una clase que extiende de <strong>SQLiteOpenHelper</strong> y que será la encargada de generar la base de datos. El método <strong>onCreate</strong> será el lugar donde podremos insertar los valores, de esta forma nos aseguramos que se hará siempre que se cree la base de datos.</p>

<p>Si estamos trabajando directamente con <strong>SQLiteOpenHelper</strong> (no estamos utilizando una librería externa de gestión de base de datos) nuestro método <strong>onCreate</strong> podría quedar de la siguiente forma:</p>

<pre class="brush: java; gutter: true; first-line: 1">    public void onCreate(SQLiteDatabase db) {
        // Sentencias de creación de base de datos
        // db.execSQL("CREATE TABLE ...");
        db.beginTransaction();
        try {
            ContentValues values = new ContentValues();
            for (int i = 0; i &lt; NOMRES.length; i++) {
                values.put("nombre", NOMBRES[i]);
                values.put("edad", EDADES[i]);
                db.insert("usuarios", null, values);
            }
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
    }
</pre>

<p>Como vemos el funcionamiento es muy sencillo. Los datos podrían venir de cualquier otra clase de nuestro código en lugar de arrays (en el ejemplo NOMBRES y EDADES). Lo importante aquí empieza en la línea 4, declaramos que vamos a iniciar una transacción, insertamos los datos, declaramos que hemos insertado los datos correctamente y finalizamos la transacción. Se utilizan transacciones para que la inserción de datos se haga de una forma más rápida.</p>

<p>Si estamos utilizando alguna librería de gestión de base de datos siempre tendremos la posibilidad de ejecutar código durante la creación de la base de datos. ORMLite por ejemplo extiende de <a href="http://ormlite.com/android/examples/DatabaseHelper.java">OrmLiteSqliteOpenHelper</a> que también incluye el método <strong>onCreate</strong>.</p>

<h5>Opción 2 - Cargar script SQL al crear la base de datos</h5>

<p>Una segunda opción y quizás la más recomendable después de la <strong>Opción 4</strong> consiste en crearnos un fichero SQL de inserción, leerlo e importarlo en el <strong>onCreate</strong>. El fichero podemos crearlo en el directorio <em>assets</em> y tendría una sentencia SQL por línea. Por ejemplo:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">INSERT INTO usuarios (nombre, edad) VALUES (&#39;usuario1&#39;, 18);
INSERT INTO usuarios (nombre, edad) VALUES (&#39;usuario2&#39;, 48);
INSERT INTO usuarios (nombre, edad) VALUES (&#39;usuario3&#39;, 30);
INSERT INTO usuarios (nombre, edad) VALUES (&#39;usuario4&#39;, 55);
INSERT INTO usuarios (nombre, edad) VALUES (&#39;usuario5&#39;, 16);
</code></pre></div>
<p>Si suponemos que el fichero se ha grabado en el directorio <em>assets</em> con el nombre <em>import.sql</em> nuestro método <strong>onCreate</strong> del <strong>SQLiteOpenHelper</strong> quedaría de la siguiente forma:</p>

<pre class="brush: java; gutter: true; first-line: 1">    public void onCreate(SQLiteDatabase db) {
        // Sentencias de creación de base de datos
        // db.execSQL("CREATE TABLE ...");
        InputStream is = null;
        try {
             is = mContext.getAssets().open("import.sql");
             if (is != null) {
                 db.beginTransaction();
                 BufferedReader reader = new BufferedReader(new InputStreamReader(is));
                 String line = reader.readLine();
                 while (!TextUtils.isEmpty(line)) {
                     db.execSQL(line);
                     line = reader.readLine();
                 }
                 db.setTransactionSuccessful();
             }
        } catch (Exception ex) {
            // Muestra log
        } finally {
            db.endTransaction();
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    // Muestra log
                }
            }
        }
    }
</pre>

<p>Como vemos resulta muy sencillo. La variable <strong>mContext</strong> podemos inicializarla en el constructor del <strong>SQLiteOpenHelper</strong>. Luego sólo tenemos que cargar el fichero, leerlo línea a línea e ir ejecutando las sentencias. Esto mismo podría valernos para el método <strong>onUpgrade</strong>, con un fichero SQL con sentencias de actualización de base de datos.</p>

<p>Esta opción es muy recomendable cuando tenemos un número considerable de datos, pero hay que tener en cuenta que es posible que se ejecute en el hilo principal (por ejemplo porque inicializamos el <em>helper</em> en una activity) llegándolo a bloquear si tarda mucho.</p>

<p>Al igual que antes, la mayoría de los gestores de base de datos proporcionan el método <strong>onCreate</strong> donde podemos realizar esta misma tarea.</p>

<h5>Opción 3 - Copiar una base de datos creada con anterioridad</h5>

<p>Esta opción y la última son las aconsejables cuando el volumen de datos es muy grande. No obstante, aunque la opción 3 pueda llegar a ser la más cómoda es, sin lugar a dudas, la que más problemas y quebraderos de cabeza puede darnos. No es la más recomendable, sin embargo es una solución posible y como tal os la presentamos en el artículo.</p>

<p>La idea se basa en crear una base de datos <em>SQLite</em>, insertar datos mediante un programa externo en nuestro ordenador, empaquetarla en el directorio <em>assets</em> de nuestra aplicación y en la creación de la base de datos darle el cambiazo a la recién creada por la nuestra.</p>

<p>Existen multitud de recursos sobre cómo realizar esta tarea, basta con una simple <a href="https://www.google.es/search?q=Using+your+own+SQLite+database+in+Android">búsqueda en Google</a> para encontrar alguno de los artículos. A continuación vamos a comentar los pasos por encima.</p>

<h6>Paso 1 - Preparar la base de datos</h6>

<p>El primer paso es preparar nuestra base de datos. Podemos utilizar la <a href="http://developer.android.com/tools/help/sqlite3.html">herramienta sqlite3</a> que incorpora el SDK de android o algún editor gráfico como <a href="http://sourceforge.net/projects/sqlitebrowser/">SQLite Database Browser</a> o <a href="http://sqliteman.com/">SQLiteman</a>. Lo importante es que nuestra base de datos debe tener una tabla con el nombre <strong>android_metadata</strong> con una única columna de nombre <strong>locale</strong> y con una fila con el valor <strong>en_US</strong>. Podemos crearla con las siguientes dos sentencias SQL:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CREATE TABLE android_metadata (locale TEXT DEFAULT &#39;en_US&#39;);
INSERT INTO android_metadata VALUES (&#39;en_US&#39;);
</code></pre></div>
<p>Una vez hecho esto creamos las tablas de nuestra aplicación e insertamos los datos necesarios.</p>

<h6>Paso 2 - Copiar la base de datos en el directorio assets</h6>

<p>Este paso, a priori sencillo, puede darnos más de un problema. El motivo es que si nuestra base de datos ocupa más de 1MB, al crear el APK la base de datos estará en el directorio <em>assets</em> pero comprimida y al leerla nos dará un error.</p>

<p>La herramienta <em>aapt</em> ignora para su compresión algunos recursos en base a su extensión, como por ejemplo mp3 o avi, porque se supone que estos ficheros ya están comprimidos. Por tanto, tenemos dos formas de evitar que la herramienta <em>aapt</em> comprima nuestro fichero de base de datos al crear el APK:</p>

<ul>
<li>  <span style="line-height: 12px"><strong>Forma fácil</strong>: Le cambiamos la extensión a .mp3</span></li>
<li>  <strong>Forma correcta</strong>: Le pasamos el parámetro &#39;-0&#39; (cero) seguido de la extensión &#39;db&#39; (o la extensión del fichero de nuestra base de datos si es otra) a la herramienta cuando vayamos a crear el APK</li>
</ul>

<h6>Paso 3 - Inicializar la base de datos y copiar la nuestra</h6>

<p>El último paso consiste en modificar nuestra clase <strong>SQLiteOpenHelper</strong> para que realice los siguientes pasos:</p>

<ol>
<li> <span style="line-height: 12px">Compruebe si la base de datos está inicializada</span></li>
<li> Si no lo está, inicialice y la sobrescriba con la base de datos del directorio assets</li>
</ol>

<p>Como dijimos antes, existen varias páginas que explican cómo realizar esta tarea. A continuación podemos ver una posible implementación del <strong>SQLiteOpenHelper</strong>.</p>

<pre class="brush: java; gutter: true; first-line: 1">import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;

public class DBHelper extends SQLiteOpenHelper {

    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = "basededatos.db";

    private Context mContext;

    public DBHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
        mContext = context;
    }

    public void createDataBase() throws IOException {
        File pathFile = mContext.getDatabasePath(DATABASE_NAME);
        boolean dbExist = checkDataBase(pathFile.getAbsolutePath());
        if(!dbExist) {
            this.getReadableDatabase();
            try {
                copyDataBase(pathFile);
            } catch (IOException e) {
                // Error copying database
            }
        }
    }

    private boolean checkDataBase(String path) {
        SQLiteDatabase checkDB = null;
        try {
            checkDB = SQLiteDatabase.openDatabase(path, null, SQLiteDatabase.OPEN_READONLY);
        } catch(Exception e){
             // Database doesn't exist
        }
        if(checkDB != null) {
            checkDB.close();
        }
        return checkDB != null;
    }

    private void copyDataBase(File pathFile) throws IOException {
        InputStream myInput = mContext.getAssets().open("basededatos.db");
        OutputStream myOutput = new FileOutputStream(pathFile);
        byte[] buffer = new byte[1024];
        int length;
        while ((length = myInput.read(buffer)) &gt; 0) {
            myOutput.write(buffer, 0, length);
        }
        myOutput.flush();
        myOutput.close();
        myInput.close();
    }

    @Override
    public void onCreate(SQLiteDatabase db) {

    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    }

}
</pre>

<p>Siempre que queramos hacer uso de los métodos <strong>getReadableDatabase()</strong> y <strong>getWritableDatabase()</strong> tendríamos que llamar al método <strong>createDatabase()</strong> que se encarga de crear la base de datos si ésta no existe (si ya existe no hace nada).</p>

<p><strong>¡Excepciones!</strong>: Si vas a utilizar este código en tu aplicación ten en cuenta las capturas de excepciones, deberás actuar en consecuencia.</p>

<h5>Opción 3&#39; - Utilizar android-sqlite-asset-helper</h5>

<p>La <a href="https://github.com/jgilfelt/android-sqlite-asset-helper">librería android-sqlite-asset-helper</a> nos facilita la implementación mediante la opción 3 pero con la ventaja de que nos ahorra prácticamente todo el trabajo. Por contra, perderemos el control de qué está ocurriendo.</p>

<p>Para utilizarla debemos seguir los siguientes pasos:</p>

<ol>
<li> <span style="line-height: 12px">Copiar <a href="https://github.com/jgilfelt/android-sqlite-asset-helper/blob/master/lib/android-sqlite-asset-helper.jar?raw=true">android-sqlite-asset-helper.jar</a> en nuestro directorio libs</span></li>
<li> Crear nuestro <em>helper</em> extendiendo de <strong>SQLiteAssetHelper</strong></li>
<li> Llamar al &quot;super constructor&quot; pasándole el nombre de la base de datos.</li>
</ol>

<p>Por ejemplo, si invocamos el super constructor de la siguiente forma:</p>

<pre class="brush: java; gutter: true; first-line: 1">super(context, "mibasededatos", null, 1);</pre>

<p>Tendremos que poner nuestra base de datos comprimida en:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">assets/databases/mibasededatos.zip
</code></pre></div>
<p>Simplemente con esto, la librería gestionará la importación de la base de datos en el caso de que no existiera.</p>

<h5>Opción 4 - Estándar</h5>

<p>¿Pero qué ocurre si los datos tardan mucho en cargar?, o ¿y si los leo desde un servicio web externo?, o ¿y si me los pasan en XML o JSON?. Bueno, si estás en una de las situaciones anteriores una solución como esta es la más indicada. Es la opción más visual (de hecho es la única que cuenta con vistas) y podemos verla reflejada en el siguiente boceto:</p>

<p><a href="http://androcode.es/wp-content/uploads/2015/02/1.-Home_pj3dla.png"><img src="http://androcode.es/wp-content/uploads/2015/02/1.-Home_pj3dla.png" alt="Mockup carga de datos"></a></p>

<p>La idea es sencilla, al entrar en nuestra pantalla principal comprobamos si están los datos cargados. Si no lo están cargamos una vista como la del boceto e iniciamos una tarea de carga.</p>

<p>El código aquí no tiene sentido, pues existen muchísimas formas de conseguir este comportamiento y depende, entre otras cosas, de nuestra forma de conectarnos a la base de datos.</p>

<p>Esta forma de resolver la carga inicial está especialmente indicada cuando tenemos un volumen de datos bastante considerable y además los datos estén en un formato no impuesto por nosotros, como por ejemplo XML o fichero de texto.</p>

<p>La idea de esta aproximación es ejecutar la tarea en un segundo plano, por lo que si la importación tarda más de un par se segundos de ejecución esta puede ser una buena opción. Podría implementarse fácilmente con una <a href="http://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask</a>, aunque los detalles ya dependen de vuestro caso.</p>

<p>Las características de esta aproximación son:</p>

<ol>
<li> Se adapta a cualquier cantidad de datos. Si la importación tarda más de un minuto no es problema, pues no estamos bloqueando el hilo principal de ejecución.</li>
<li> Tendremos que diseñar los layouts, gestionar la carga en segundo plano y actualizar la vista cuando sea necesario.</li>
</ol>

<h5>Conclusiones</h5>

<p>Como vemos es relativamente sencillo incorporar unos datos precargados a nuestras aplicaciones android.</p>

<p>En ese artículo se han presentado 4 +1 formas de realizar esta tarea. Y vosotros, ¿utilizáis otros mecanismos?, si habéis utilizado alguna de las propuestas, ¿cuál ha sido vuestra experiencia?.</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page3">Más antiguas</a>
  
  
    
      <a class="pagination-item newer" href="/">Más nuevas</a>
    
  
</div>

    </div>

  </body>
</html>
